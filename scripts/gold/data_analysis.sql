-- ============================================================
-- Exploratory Data Analysis (EDA)
-- ============================================================
-- Sections:
-- 1. Database Exploration
-- 2. Dimensions Exploration
-- 3. Date Exploration
-- 4. Measures Exploration
-- 5. Magnitude Analysis
-- 6. Ranking Exploration
-- ============================================================

USE CATALOG datawarehouse;

-- ============================================================
-- 1. Database Exploration
-- ============================================================

-- Explore all objects in the database
SELECT * FROM information_schema.tables;

-- Explore all columns in the database
SELECT * FROM information_schema.columns;


-- ============================================================
-- 2. Dimensions Exploration
-- ============================================================

-- Explore all customer countries
SELECT DISTINCT country FROM gold.dim_customers;

-- Explore all product categories (major divisions)
SELECT DISTINCT category FROM gold.dim_products;

-- Explore all product subcategories (minor divisions)
SELECT DISTINCT sub_category FROM gold.dim_products;

-- Explore all product names
SELECT DISTINCT product_name FROM gold.dim_products;

-- Explore customer segments by category, subcategory, and product
SELECT DISTINCT category, sub_category, product_name 
FROM gold.dim_products 
ORDER BY 1, 2, 3;


-- ============================================================
-- 3. Date Exploration
-- ============================================================

-- Find the date of the first and last order
SELECT order_date FROM gold.fact_sales;

SELECT MIN(order_date) AS first_order, 
       MAX(order_date) AS last_order 
FROM gold.fact_sales;

-- How many years of sales are available?
SELECT DATEDIFF(YEAR, MIN(order_date), MAX(order_date)) AS years_of_sales 
FROM gold.fact_sales;

-- How many months of sales are available?
SELECT DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS months_of_sales 
FROM gold.fact_sales;

-- Find the youngest and oldest customer birth dates
SELECT MIN(birth_date) AS oldest_birthdate, 
       MAX(birth_date) AS youngest_birthdate 
FROM gold.dim_customers;

-- Find the ages of the youngest and oldest customers
SELECT DATEDIFF(YEAR, MIN(birth_date), GETDATE()) AS oldest_age, 
       DATEDIFF(YEAR, MAX(birth_date), GETDATE()) AS youngest_age 
FROM gold.dim_customers;


-- ============================================================
-- 4. Measures Exploration
-- ============================================================

-- Find the total sales
SELECT SUM(sales_amount) AS total_sales 
FROM gold.fact_sales;

-- Find the total items sold
SELECT SUM(quantity) AS total_quantity 
FROM gold.fact_sales;

-- Find the average selling price
SELECT AVG(price) AS avg_price 
FROM gold.fact_sales;

-- Find the total number of orders (includes duplicates)
SELECT COUNT(order_number) AS total_orders 
FROM gold.fact_sales;

-- Find the total number of unique orders
SELECT COUNT(DISTINCT order_number) AS total_orders 
FROM gold.fact_sales;

-- Find the total number of products
SELECT COUNT(product_key) AS total_products 
FROM gold.dim_products;

-- Find the total number of customers
SELECT COUNT(customer_key) AS total_customers 
FROM gold.dim_customers;

-- Find the number of customers who have placed an order
SELECT COUNT(DISTINCT customer_key) AS active_customers 
FROM gold.fact_sales;

-- Generate a report with all key business metrics
SELECT 'Total Sales' AS measure_name, SUM(sales_amount) AS measure_value 
FROM gold.fact_sales
UNION ALL
SELECT 'Total Quantity', SUM(quantity) 
FROM gold.fact_sales
UNION ALL
SELECT 'Average Price', AVG(price) 
FROM gold.fact_sales
UNION ALL
SELECT 'Total Orders', COUNT(DISTINCT order_number) 
FROM gold.fact_sales
UNION ALL
SELECT 'Total Products', COUNT(product_key) 
FROM gold.dim_products
UNION ALL
SELECT 'Total Customers', COUNT(customer_key) 
FROM gold.dim_customers
UNION ALL
SELECT 'Total Active Customers', COUNT(DISTINCT customer_key) 
FROM gold.fact_sales;


-- ============================================================
-- 5. Magnitude Analysis
-- ============================================================

-- Total customers by country
SELECT country, COUNT(customer_key) AS total_customers 
FROM gold.dim_customers 
GROUP BY country 
ORDER BY total_customers DESC;

-- Total customers by gender
SELECT gender, COUNT(customer_key) AS total_customers 
FROM gold.dim_customers 
GROUP BY gender 
ORDER BY total_customers DESC;

-- Total products by category
SELECT category, COUNT(product_key) AS total_products 
FROM gold.dim_products 
GROUP BY category 
ORDER BY total_products DESC;

-- Average cost per product category
SELECT category, AVG(product_cost) AS avg_costs 
FROM gold.dim_products 
GROUP BY category 
ORDER BY avg_costs DESC;

-- Total revenue generated by each category
SELECT SUM(fs.sales_amount) AS total_revenue, dp.category 
FROM gold.fact_sales fs
LEFT JOIN gold.dim_products dp
       ON dp.product_key = fs.product_key 
GROUP BY dp.category;

-- Total revenue generated by each customer
SELECT SUM(fs.sales_amount) AS total_sales, dc.customer_key 
FROM gold.fact_sales fs
LEFT JOIN datawarehouse.gold.dim_customers dc
       ON dc.customer_key = fs.customer_key
GROUP BY dc.customer_key 
ORDER BY total_sales DESC;

-- Distribution of sold items across countries
SELECT SUM(fs.sales_amount) AS total_sold_items, dc.country 
FROM gold.fact_sales fs
LEFT JOIN datawarehouse.gold.dim_customers dc
       ON dc.customer_key = fs.customer_key
GROUP BY dc.country 
ORDER BY total_sold_items DESC;


-- ============================================================
-- 6. Ranking Exploration
-- ============================================================

-- Top 5 products by revenue
SELECT SUM(fs.sales_amount) AS total_sales, dc.product_key 
FROM gold.fact_sales fs
LEFT JOIN datawarehouse.gold.dim_products dc
       ON dc.product_key = fs.product_key
GROUP BY dc.product_key 
ORDER BY total_sales DESC 
LIMIT 5;

-- Bottom 5 products by revenue
SELECT SUM(fs.sales_amount) AS total_sales, dc.product_key 
FROM gold.fact_sales fs
LEFT JOIN datawarehouse.gold.dim_products dc
       ON dc.product_key = fs.product_key
GROUP BY dc.product_key 
ORDER BY total_sales ASC 
LIMIT 5;

-- Top 5 subcategories by revenue
SELECT SUM(fs.sales_amount) AS total_sales, dc.sub_category 
FROM gold.fact_sales fs
LEFT JOIN datawarehouse.gold.dim_products dc
       ON dc.product_key = fs.product_key
GROUP BY dc.sub_category 
ORDER BY total_sales DESC 
LIMIT 5;

-- Top 10 customers by revenue
SELECT SUM(fs.sales_amount) AS total_sales, dc.customer_key 
FROM gold.fact_sales fs
LEFT JOIN datawarehouse.gold.dim_customers dc
       ON dc.customer_key = fs.customer_key
GROUP BY dc.customer_key 
ORDER BY total_sales DESC 
LIMIT 10;

-- Bottom 3 customers with the fewest orders
SELECT COUNT(DISTINCT fs.order_number) AS total_orders, dc.customer_key 
FROM gold.fact_sales fs
LEFT JOIN datawarehouse.gold.dim_customers dc
       ON dc.customer_key = fs.customer_key
GROUP BY dc.customer_key 
ORDER BY total_orders ASC 
LIMIT 3;

-- ============================================================
-- Advance Analytics
-- ============================================================
-- Sections:
-- 7. Change Over Time Analysis
-- 8. Cumulative Analysis
-- 9. Performance Analysis
-- 10. Part to whole (Proportion) Analysis
-- 11. Data Segmentation
-- 12. Reporting
-- ============================================================

-- ============================================================
-- 7. Change Over Time Analysis
-- ============================================================
-- Analyse Sales performance over time

-- Yearly total sales
SELECT 
    YEAR(order_date) AS order_year, 
    SUM(sales_amount) AS total_sales 
FROM gold.fact_sales 
WHERE order_date IS NOT NULL
GROUP BY YEAR(order_date)
ORDER BY YEAR(order_date);

-- Yearly total sales and total customers
SELECT 
    YEAR(order_date) AS order_year, 
    SUM(sales_amount) AS total_sales, 
    COUNT(DISTINCT customer_key) AS total_customers 
FROM gold.fact_sales 
WHERE order_date IS NOT NULL
GROUP BY YEAR(order_date)
ORDER BY YEAR(order_date);

-- Yearly total sales, total customers, and total quantity sold
SELECT 
    YEAR(order_date) AS order_year, 
    SUM(sales_amount) AS total_sales, 
    COUNT(DISTINCT customer_key) AS total_customers, 
    SUM(quantity) AS total_quantity 
FROM gold.fact_sales 
WHERE order_date IS NOT NULL
GROUP BY YEAR(order_date)
ORDER BY YEAR(order_date);


-- Discover seasonality trends by month
SELECT 
    MONTH(order_date) AS order_month, 
    SUM(sales_amount) AS total_sales, 
    COUNT(DISTINCT customer_key) AS total_customers, 
    SUM(quantity) AS total_quantity 
FROM gold.fact_sales 
WHERE order_date IS NOT NULL
GROUP BY MONTH(order_date)
ORDER BY MONTH(order_date);

-- Yearly and monthly breakdown of sales
SELECT 
    YEAR(order_date) AS order_year,
    MONTH(order_date) AS order_month, 
    SUM(sales_amount) AS total_sales, 
    COUNT(DISTINCT customer_key) AS total_customers, 
    SUM(quantity) AS total_quantity 
FROM gold.fact_sales 
WHERE order_date IS NOT NULL
GROUP BY YEAR(order_date), MONTH(order_date)
ORDER BY YEAR(order_date), MONTH(order_date);

-- ============================================================
-- 8. Cumulative Analysis
-- ============================================================
-- Calculate total monthly sales and the running total of sales over time.

-- Total sales per month
SELECT 
    SUM(sales_amount) AS total_sales,
    MONTH(order_date) AS monthly 
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY MONTH(order_date);

-- Running total of sales over time (monthly)
SELECT 
    monthly, 
    total_sales, 
    SUM(total_sales) OVER(ORDER BY monthly) AS running_total_sales
FROM (
    SELECT 
        SUM(sales_amount) AS total_sales,
        MONTH(order_date) AS monthly 
    FROM gold.fact_sales
    WHERE order_date IS NOT NULL
    GROUP BY MONTH(order_date)
);

-- Running total of sales per year
SELECT 
    monthly, 
    total_sales, 
    SUM(total_sales) OVER(PARTITION BY monthly ORDER BY monthly) AS running_total_sales
FROM (
    SELECT 
        SUM(sales_amount) AS total_sales,
        DATE_TRUNC('month', order_date) AS monthly 
    FROM gold.fact_sales
    WHERE order_date IS NOT NULL
    GROUP BY DATE_TRUNC('month', order_date)
);

-- Running total of yearly sales
SELECT 
    monthly, 
    total_sales, 
    SUM(total_sales) OVER(ORDER BY monthly) AS running_total_sales
FROM (
    SELECT 
        SUM(sales_amount) AS total_sales,
        DATE_TRUNC('year', order_date) AS monthly 
    FROM gold.fact_sales
    WHERE order_date IS NOT NULL
    GROUP BY DATE_TRUNC('year', order_date)
);

-- Moving average of yearly sales
SELECT 
    monthly, 
    total_sales, 
    SUM(total_sales) OVER(ORDER BY monthly) AS running_total_sales,
    AVG(avg_price) OVER(ORDER BY monthly) AS moving_average
FROM (
    SELECT 
        SUM(sales_amount) AS total_sales,
        AVG(price) AS avg_price,
        DATE_TRUNC('year', order_date) AS monthly 
    FROM gold.fact_sales
    WHERE order_date IS NOT NULL
    GROUP BY DATE_TRUNC('year', order_date)
);

-- ============================================================
-- 9. Performance Analysis
-- ============================================================
-- Analyze yearly product performance compared to average and previous year sales.

-- Yearly product performance
SELECT 
    YEAR(f.order_date) AS order_year,
    p.product_name,
    SUM(f.sales_amount) AS current_sales
FROM gold.fact_sales f 
LEFT JOIN gold.dim_products p 
    ON f.product_key = p.product_key
WHERE order_date IS NOT NULL
GROUP BY YEAR(f.order_date), p.product_name;

-- Using CTE to find current and average sales per product
WITH yearly_product_sales AS (
    SELECT 
        YEAR(f.order_date) AS order_year,
        p.product_name,
        SUM(f.sales_amount) AS current_sales
    FROM gold.fact_sales f 
    LEFT JOIN gold.dim_products p 
        ON f.product_key = p.product_key
    WHERE order_date IS NOT NULL
    GROUP BY YEAR(f.order_date), p.product_name
)
SELECT 
    order_year, 
    product_name, 
    current_sales,
    AVG(current_sales) OVER(PARTITION BY product_name) AS avg_sales
FROM yearly_product_sales 
ORDER BY product_name, order_year;

-- Calculate difference from average
WITH yearly_product_sales AS (
    SELECT 
        YEAR(f.order_date) AS order_year,
        p.product_name,
        SUM(f.sales_amount) AS current_sales
    FROM gold.fact_sales f 
    LEFT JOIN gold.dim_products p 
        ON f.product_key = p.product_key
    WHERE order_date IS NOT NULL
    GROUP BY YEAR(f.order_date), p.product_name
)
SELECT 
    order_year, 
    product_name, 
    current_sales,
    AVG(current_sales) OVER(PARTITION BY product_name) AS avg_sales, 
    current_sales - AVG(current_sales) OVER(PARTITION BY product_name) AS diff_avg
FROM yearly_product_sales 
ORDER BY product_name, order_year;

-- Add performance flag for above/below average sales
WITH yearly_product_sales AS (
    SELECT 
        YEAR(f.order_date) AS order_year,
        p.product_name,
        SUM(f.sales_amount) AS current_sales
    FROM gold.fact_sales f 
    LEFT JOIN gold.dim_products p 
        ON f.product_key = p.product_key
    WHERE order_date IS NOT NULL
    GROUP BY YEAR(f.order_date), p.product_name
)
SELECT 
    order_year, 
    product_name, 
    current_sales,
    AVG(current_sales) OVER(PARTITION BY product_name) AS avg_sales, 
    current_sales - AVG(current_sales) OVER(PARTITION BY product_name) AS diff_avg,
    CASE 
        WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) > 0 THEN 'Above Avg'
        WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) < 0 THEN 'Below Avg'
        ELSE 'Avg'
    END AS sales_status
FROM yearly_product_sales 
ORDER BY product_name, order_year;

-- Compare each product’s sales to its previous year
WITH yearly_product_sales AS (
    SELECT 
        YEAR(f.order_date) AS order_year,
        p.product_name,
        SUM(f.sales_amount) AS current_sales
    FROM gold.fact_sales f 
    LEFT JOIN gold.dim_products p 
        ON f.product_key = p.product_key
    WHERE order_date IS NOT NULL
    GROUP BY YEAR(f.order_date), p.product_name
)
SELECT 
    order_year, 
    product_name, 
    current_sales,
    AVG(current_sales) OVER(PARTITION BY product_name) AS avg_sales, 
    current_sales - AVG(current_sales) OVER(PARTITION BY product_name) AS diff_avg,
    CASE 
        WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) > 0 THEN 'Above Avg'
        WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) < 0 THEN 'Below Avg'
        ELSE 'Avg'
    END AS sales_status,
    LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) AS previous_year_sale,
    current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) AS diff_previous_year
FROM yearly_product_sales 
ORDER BY product_name, order_year;

-- Add flag to indicate improvement or decline vs. previous year
WITH yearly_product_sales AS (
    SELECT 
        YEAR(f.order_date) AS order_year,
        p.product_name,
        SUM(f.sales_amount) AS current_sales
    FROM gold.fact_sales f 
    LEFT JOIN gold.dim_products p 
        ON f.product_key = p.product_key
    WHERE order_date IS NOT NULL
    GROUP BY YEAR(f.order_date), p.product_name
)
SELECT 
    order_year,
    product_name,
    current_sales,
    AVG(current_sales) OVER (PARTITION BY product_name) AS avg_sales,
    current_sales - AVG(current_sales) OVER (PARTITION BY product_name) AS diff_avg,
    CASE 
        WHEN current_sales - AVG(current_sales) OVER (PARTITION BY product_name) > 0 THEN 'Above Avg'
        WHEN current_sales - AVG(current_sales) OVER (PARTITION BY product_name) < 0 THEN 'Below Avg'
        ELSE 'Avg'
    END AS sales_status,
    LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS previous_year_sale,
    current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS diff_previous_year,
    CASE 
        WHEN current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) > 0 THEN 'Increased'
        WHEN current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) < 0 THEN 'Decreased'
        ELSE 'Same'
    END AS sales_status_previous_year
FROM yearly_product_sales
ORDER BY product_name, order_year;

-- ============================================================
-- 10. Part-to-Whole (Proportion) Analysis
-- ============================================================
-- Identify which product categories contribute most to total sales.

-- Total sales by category
SELECT 
    category, 
    SUM(sales_amount) AS total_sales
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p 
    ON f.product_key = p.product_key
GROUP BY category;

-- Overall sales (total across all categories)
WITH category_sales AS (
    SELECT 
        category, 
        SUM(sales_amount) AS total_sales
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p 
        ON f.product_key = p.product_key
    GROUP BY category
)
SELECT 
    category, 
    total_sales,
    SUM(total_sales) OVER() AS overall_sales 
FROM category_sales;

-- Proportion of each category relative to total sales
WITH category_sales AS (
    SELECT 
        category, 
        SUM(sales_amount) AS total_sales
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p 
        ON f.product_key = p.product_key
    GROUP BY category
)
SELECT 
    category, 
    total_sales,
    SUM(total_sales) OVER() AS overall_sales,
    ROUND((total_sales / SUM(total_sales) OVER()) * 100, 2) AS sales_percentage
FROM category_sales;

-- Formatted and ordered version
WITH category_sales AS (
    SELECT 
        category, 
        SUM(sales_amount) AS total_sales
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p 
        ON f.product_key = p.product_key
    GROUP BY category
)
SELECT 
    category, 
    total_sales,
    SUM(total_sales) OVER() AS overall_sales,
    CONCAT(ROUND((total_sales / SUM(total_sales) OVER()) * 100, 2), '%') AS sales_percentage
FROM category_sales
ORDER BY total_sales DESC;

-- ============================================================
-- 11. Data Segmentation
-- ============================================================
-- Segment products and customers for deeper insights.

-- Segment products into cost ranges
SELECT 
    product_key,
    product_name,
    product_cost,
    CASE 
        WHEN product_cost < 100 THEN 'Below 100'
        WHEN product_cost BETWEEN 100 AND 500 THEN '100-500'
        WHEN product_cost BETWEEN 500 AND 1000 THEN '500-1000'
        ELSE 'Above 1000'
    END AS cost_range
FROM gold.dim_products;

-- Count how many products fall into each cost segment
WITH product_segments AS (
    SELECT 
        product_key,
        product_name,
        product_cost,
        CASE 
            WHEN product_cost < 100 THEN 'Below 100'
            WHEN product_cost BETWEEN 100 AND 500 THEN '100-500'
            WHEN product_cost BETWEEN 500 AND 1000 THEN '500-1000'
            ELSE 'Above 1000'
        END AS cost_range
    FROM gold.dim_products
)
SELECT 
    cost_range, 
    COUNT(product_key) AS total_product  
FROM product_segments 
GROUP BY cost_range 
ORDER BY cost_range DESC;

-- Segment customers based on spending and activity
-- Criteria:
-- - VIP: ≥12 months history and spending > $5000
-- - Regular: ≥12 months history and spending ≤ $5000
-- - New: <12 months history

-- Calculate customer lifespan and total spending
SELECT 
    c.customer_key,
    SUM(f.sales_amount) AS total_spending,
    MIN(order_date) AS first_order,
    MAX(order_date) AS last_order,
    DATEDIFF(month, MIN(order_date), MAX(order_date)) AS lifespan
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c 
    ON f.customer_key = c.customer_key
GROUP BY c.customer_key;

-- Assign customer segments based on lifespan and spending
WITH customer_spending AS (
    SELECT 
        c.customer_key,
        SUM(f.sales_amount) AS total_spending,
        MIN(order_date) AS first_order,
        MAX(order_date) AS last_order,
        DATEDIFF(month, MIN(order_date), MAX(order_date)) AS lifespan
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_customers c 
        ON f.customer_key = c.customer_key
    GROUP BY c.customer_key
)
SELECT 
    customer_key, 
    total_spending,
    lifespan,
    CASE 
        WHEN lifespan >= 12 AND total_spending > 5000 THEN 'VIP'
        WHEN lifespan >= 12 AND total_spending <= 5000 THEN 'Regular'
        ELSE 'New'
    END AS customer_segment
FROM customer_spending;

-- Count customers per segment
WITH customer_spending AS (
    SELECT 
        c.customer_key,
        SUM(f.sales_amount) AS total_spending,
        MIN(order_date) AS first_order,
        MAX(order_date) AS last_order,
        DATEDIFF(month, MIN(order_date), MAX(order_date)) AS lifespan
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_customers c 
        ON f.customer_key = c.customer_key
    GROUP BY c.customer_key
)
SELECT 
    customer_segment, 
    COUNT(customer_key) AS total_customers 
FROM (
    SELECT 
        customer_key, 
        total_spending,
        lifespan,
        CASE 
            WHEN lifespan >= 12 AND total_spending > 5000 THEN 'VIP'
            WHEN lifespan >= 12 AND total_spending <= 5000 THEN 'Regular'
            ELSE 'New'
        END AS customer_segment
    FROM customer_spending
) t 
GROUP BY customer_segment 
ORDER BY total_customers;

-- ============================================================
-- 12. REPORTING
-- ============================================================
-- CUSTOMER REPORT
-- Purpose:
--   This report consolidates key customer metrics and behaviors.
--   It provides customer-level insights for dashboards and analysis.
--
-- Highlights:
--   1. Retrieves essential customer and transaction fields.
--   2. Segments customers into categories (VIP, Regular, New) and age groups.
--   3. Aggregates customer-level metrics:
--        - Total orders
--        - Total sales
--        - Total quantity purchased
--        - Total distinct products
--        - Lifespan (in months)
--   4. Calculates key KPIs:
--        - Recency (months since last order)
--        - Average order value
--        - Average monthly spend
-- ============================================================

-- ============================================================
-- 1. BASE QUERY: Retrieve core customer and transaction data
-- ============================================================
SELECT 
    f.order_number,
    f.product_key,
    f.order_date,
    f.sales_amount,
    f.quantity,
    c.customer_key,
    c.customer_number,
    c.first_name,
    c.last_name,
    c.birth_date
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
    ON f.customer_key = c.customer_key
WHERE f.order_date IS NOT NULL;

-- ============================================================
-- 2. TRANSFORMATIONS: Add derived fields (customer name, age)
-- ============================================================
WITH base_query AS (
    SELECT 
        f.order_number,
        f.product_key,
        f.order_date,
        f.sales_amount,
        f.quantity,
        c.customer_key,
        c.customer_number,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        DATEDIFF(YEAR, c.birth_date, GETDATE()) AS customer_age
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_customers c
        ON f.customer_key = c.customer_key
    WHERE f.order_date IS NOT NULL
)
SELECT * 
FROM base_query;

-- ============================================================
-- 3. AGGREGATIONS: Compute customer-level metrics
-- ============================================================
WITH base_query AS (
    SELECT 
        f.order_number,
        f.product_key,
        f.order_date,
        f.sales_amount,
        f.quantity,
        c.customer_key,
        c.customer_number,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        DATEDIFF(YEAR, c.birth_date, GETDATE()) AS customer_age
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_customers c
        ON f.customer_key = c.customer_key
    WHERE f.order_date IS NOT NULL
),
customer_aggregations AS (
    SELECT 
        customer_key,
        customer_number,
        customer_name,
        customer_age,
        COUNT(DISTINCT order_number) AS total_orders,
        SUM(sales_amount) AS total_sales,
        SUM(quantity) AS total_quantity,
        COUNT(DISTINCT product_key) AS total_products,
        MAX(order_date) AS last_order_date,
        DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan
    FROM base_query
    GROUP BY customer_key, customer_number, customer_name, customer_age
)
SELECT * 
FROM customer_aggregations;

 -- ============================================================
-- 4. CUSTOMER SEGMENTATION & AGE GROUPS
-- ============================================================
WITH base_query AS (
    SELECT 
        f.order_number,
        f.product_key,
        f.order_date,
        f.sales_amount,
        f.quantity,
        c.customer_key,
        c.customer_number,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        DATEDIFF(YEAR, c.birth_date, GETDATE()) AS customer_age
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_customers c
        ON f.customer_key = c.customer_key
    WHERE f.order_date IS NOT NULL
),
customer_aggregations AS (
    SELECT 
        customer_key,
        customer_number,
        customer_name,
        customer_age,
        COUNT(DISTINCT order_number) AS total_orders,
        SUM(sales_amount) AS total_sales,
        SUM(quantity) AS total_quantity,
        COUNT(DISTINCT product_key) AS total_products,
        MAX(order_date) AS last_order_date,
        DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan
    FROM base_query
    GROUP BY customer_key, customer_number, customer_name, customer_age
)
SELECT 
    customer_key,
    customer_number,
    customer_name,
    customer_age,
    CASE 
        WHEN customer_age < 20 THEN 'Under 20'
        WHEN customer_age BETWEEN 20 AND 29 THEN '20-29'
        WHEN customer_age BETWEEN 30 AND 39 THEN '30-39'
        WHEN customer_age BETWEEN 40 AND 49 THEN '40-49'
        ELSE '50 and above'
    END AS age_group,
    total_orders,
    total_sales,
    total_quantity,
    total_products,
    last_order_date,
    lifespan,
    CASE 
        WHEN lifespan >= 12 AND total_sales > 5000 THEN 'VIP'
        WHEN lifespan >= 12 AND total_sales <= 5000 THEN 'Regular'
        ELSE 'New'
    END AS customer_segment
FROM customer_aggregations;

-- ============================================================
-- 5. RECENCY: Calculate months since last order
-- ============================================================
WITH base_query AS (
    SELECT 
        f.order_number,
        f.product_key,
        f.order_date,
        f.sales_amount,
        f.quantity,
        c.customer_key,
        c.customer_number,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        DATEDIFF(YEAR, c.birth_date, GETDATE()) AS customer_age
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_customers c
        ON f.customer_key = c.customer_key
    WHERE f.order_date IS NOT NULL
),
customer_aggregations AS (
    SELECT 
        customer_key,
        customer_number,
        customer_name,
        customer_age,
        COUNT(DISTINCT order_number) AS total_orders,
        SUM(sales_amount) AS total_sales,
        SUM(quantity) AS total_quantity,
        COUNT(DISTINCT product_key) AS total_products,
        MAX(order_date) AS last_order_date,
        DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan
    FROM base_query
    GROUP BY customer_key, customer_number, customer_name, customer_age
)
SELECT 
    customer_key,
    customer_number,
    customer_name,
    customer_age,
    CASE 
        WHEN customer_age < 20 THEN 'Under 20'
        WHEN customer_age BETWEEN 20 AND 29 THEN '20-29'
        WHEN customer_age BETWEEN 30 AND 39 THEN '30-39'
        WHEN customer_age BETWEEN 40 AND 49 THEN '40-49'
        ELSE '50 and above'
    END AS age_group,
    total_orders,
    total_sales,
    total_quantity,
    total_products,
    last_order_date,
    DATEDIFF(MONTH, last_order_date, GETDATE()) AS recency,
    lifespan,
    CASE 
        WHEN lifespan >= 12 AND total_sales > 5000 THEN 'VIP'
        WHEN lifespan >= 12 AND total_sales <= 5000 THEN 'Regular'
        ELSE 'New'
    END AS customer_segment
FROM customer_aggregations;

-- ============================================================
-- 6. AVERAGE ORDER VALUE (AOV)
-- ============================================================
WITH base_query AS (
    SELECT 
        f.order_number,
        f.product_key,
        f.order_date,
        f.sales_amount,
        f.quantity,
        c.customer_key,
        c.customer_number,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        DATEDIFF(YEAR, c.birth_date, GETDATE()) AS customer_age
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_customers c
        ON f.customer_key = c.customer_key
    WHERE f.order_date IS NOT NULL
),
customer_aggregations AS (
    SELECT 
        customer_key,
        customer_number,
        customer_name,
        customer_age,
        COUNT(DISTINCT order_number) AS total_orders,
        SUM(sales_amount) AS total_sales,
        SUM(quantity) AS total_quantity,
        COUNT(DISTINCT product_key) AS total_products,
        MAX(order_date) AS last_order_date,
        DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan
    FROM base_query
    GROUP BY customer_key, customer_number, customer_name, customer_age
)
SELECT 
    customer_key,
    customer_number,
    customer_name,
    customer_age,
    CASE 
        WHEN customer_age < 20 THEN 'Under 20'
        WHEN customer_age BETWEEN 20 AND 29 THEN '20-29'
        WHEN customer_age BETWEEN 30 AND 39 THEN '30-39'
        WHEN customer_age BETWEEN 40 AND 49 THEN '40-49'
        ELSE '50 and above'
    END AS age_group,
    total_orders,
    total_sales,
    total_quantity,
    total_products,
    last_order_date,
    DATEDIFF(MONTH, last_order_date, GETDATE()) AS recency,
    lifespan,
    CASE 
        WHEN lifespan >= 12 AND total_sales > 5000 THEN 'VIP'
        WHEN lifespan >= 12 AND total_sales <= 5000 THEN 'Regular'
        ELSE 'New'
    END AS customer_segment,
    CASE 
        WHEN total_orders = 0 THEN 0 
        ELSE total_sales / total_orders 
    END AS avg_order_value
FROM customer_aggregations;

-- ============================================================
-- 7. AVERAGE MONTHLY SPEND
-- ============================================================
WITH base_query AS (
    SELECT 
        f.order_number,
        f.product_key,
        f.order_date,
        f.sales_amount,
        f.quantity,
        c.customer_key,
        c.customer_number,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        DATEDIFF(YEAR, c.birth_date, GETDATE()) AS customer_age
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_customers c
        ON f.customer_key = c.customer_key
    WHERE f.order_date IS NOT NULL
),
customer_aggregations AS (
    SELECT 
        customer_key,
        customer_number,
        customer_name,
        customer_age,
        COUNT(DISTINCT order_number) AS total_orders,
        SUM(sales_amount) AS total_sales,
        SUM(quantity) AS total_quantity,
        COUNT(DISTINCT product_key) AS total_products,
        MAX(order_date) AS last_order_date,
        DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan
    FROM base_query
    GROUP BY customer_key, customer_number, customer_name, customer_age
)
SELECT 
    customer_key,
    customer_number,
    customer_name,
    customer_age,
    CASE 
        WHEN customer_age < 20 THEN 'Under 20'
        WHEN customer_age BETWEEN 20 AND 29 THEN '20-29'
        WHEN customer_age BETWEEN 30 AND 39 THEN '30-39'
        WHEN customer_age BETWEEN 40 AND 49 THEN '40-49'
        ELSE '50 and above'
    END AS age_group,
    total_orders,
    total_sales,
    total_quantity,
    total_products,
    last_order_date,
    DATEDIFF(MONTH, last_order_date, GETDATE()) AS recency,
    lifespan,
    CASE 
        WHEN lifespan >= 12 AND total_sales > 5000 THEN 'VIP'
        WHEN lifespan >= 12 AND total_sales <= 5000 THEN 'Regular'
        ELSE 'New'
    END AS customer_segment,
    CASE 
        WHEN total_orders = 0 THEN 0 
        ELSE total_sales / total_orders 
    END AS avg_order_value,
    CASE 
        WHEN lifespan = 0 THEN total_sales 
        ELSE total_sales / lifespan 
    END AS avg_monthly_spend
FROM customer_aggregations;

-- ============================================================
-- FINAL CUSTOMER REPORT VIEW
-- Purpose:
--   Creates a consolidated view of customer metrics for reporting and dashboards.
--   Includes KPIs such as total sales, orders, recency, lifespan, and segment classification.
-- ============================================================
CREATE VIEW gold.report_customers AS 
WITH base_query AS (
    SELECT 
        f.order_number,
        f.product_key,
        f.order_date,
        f.sales_amount,
        f.quantity,
        c.customer_key,
        c.customer_number,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        DATEDIFF(YEAR, c.birth_date, GETDATE()) AS customer_age
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_customers c
        ON f.customer_key = c.customer_key
    WHERE f.order_date IS NOT NULL
),
customer_aggregations AS (
    SELECT 
        customer_key,
        customer_number,
        customer_name,
        customer_age,
        COUNT(DISTINCT order_number) AS total_orders,
        SUM(sales_amount) AS total_sales,
        SUM(quantity) AS total_quantity,
        COUNT(DISTINCT product_key) AS total_products,
        MAX(order_date) AS last_order_date,
        DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan
    FROM base_query
    GROUP BY customer_key, customer_number, customer_name, customer_age
)
SELECT 
    customer_key,
    customer_number,
    customer_name,
    customer_age,
    CASE 
        WHEN customer_age < 20 THEN 'Under 20'
        WHEN customer_age BETWEEN 20 AND 29 THEN '20-29'
        WHEN customer_age BETWEEN 30 AND 39 THEN '30-39'
        WHEN customer_age BETWEEN 40 AND 49 THEN '40-49'
        ELSE '50 and above'
    END AS age_group,
    total_orders,
    total_sales,
    total_quantity,
    total_products,
    last_order_date,
    DATEDIFF(MONTH, last_order_date, GETDATE()) AS recency,
    lifespan,
    CASE 
        WHEN lifespan >= 12 AND total_sales > 5000 THEN 'VIP'
        WHEN lifespan >= 12 AND total_sales <= 5000 THEN 'Regular'
        ELSE 'New'
    END AS customer_segment,
    CASE 
        WHEN total_orders = 0 THEN 0 
        ELSE total_sales / total_orders 
    END AS avg_order_value,
    CASE 
        WHEN lifespan = 0 THEN total_sales 
        ELSE total_sales / lifespan 
    END AS avg_monthly_spend
FROM customer_aggregations;

-- ============================================================
-- PRODUCT REPORT
-- Purpose:
--   This report consolidates key product metrics and behaviors.
--   It provides detailed product-level insights for dashboards and analysis.
--
-- Highlights:
--   1. Gathers essential fields such as product names, categories, subcategories, and costs.
--   2. Segments products by revenue to identify high performers, mid-range, or low performers.
--   3. Aggregates product-level metrics:
--        - Total orders
--        - Total sales
--        - Total quantity sold
--        - Lifespan (in months)
--   4. Calculates key KPIs:
--        - Recency (months since last sale)
--        - Average monthly revenue
--        - Average order revenue (AOR)
-- ============================================================

-- ============================================================
-- 1. BASE QUERY: Retrieve core product and sales information
-- ============================================================
SELECT 
    f.order_number,
    f.product_key,
    f.order_date,
    f.sales_amount,
    f.quantity,
    p.product_name,
    p.product_line,
    p.category,
    p.sub_category,
    p.product_cost,
    p.start_date
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
    ON f.product_key = p.product_key
WHERE f.order_date IS NOT NULL;

-- ============================================================
-- 2. TRANSFORMATIONS
-- Note:
--   No transformations are needed, but the query is converted to a CTE
--   for modularity and reusability in later aggregations.
-- ============================================================
WITH base_query AS (
    SELECT 
        f.order_number,
        f.customer_key,
        f.order_date,
        f.sales_amount,
        f.quantity,
        p.product_key,
        p.product_name,
        p.product_line,
        p.category,
        p.sub_category,
        p.product_cost,
        p.start_date
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p
        ON f.product_key = p.product_key
    WHERE f.order_date IS NOT NULL
)
SELECT * 
FROM base_query;

-- ============================================================
-- 3. PRODUCT AGGREGATIONS
--   Aggregate product-level metrics such as total sales,
--   total orders, total quantity, and average selling price.
-- ============================================================
WITH base_query AS (
    SELECT 
        f.order_number,
        f.customer_key,
        f.order_date,
        f.sales_amount,
        f.quantity,
        p.product_key,
        p.product_name,
        p.product_line,
        p.category,
        p.sub_category,
        p.product_cost,
        p.start_date
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p
        ON f.product_key = p.product_key
    WHERE f.order_date IS NOT NULL
)
SELECT 
    product_key,
    product_name,
    category,
    sub_category,
    product_cost,
    DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan,
    MAX(order_date) AS last_sale_date,
    COUNT(DISTINCT order_number) AS total_orders,
    COUNT(DISTINCT customer_key) AS total_customers,
    SUM(sales_amount) AS total_sales,
    SUM(quantity) AS total_quantity,
    ROUND(AVG(CAST(sales_amount AS FLOAT) / NULLIF(quantity, 0)), 1) AS avg_selling_price
FROM base_query
GROUP BY 
    product_key,
    product_name,
    category,
    sub_category,
    product_cost;

-- ============================================================
-- 4. FINAL PRODUCT REPORT QUERY
--   Adds segmentation, KPIs, and revenue-based classifications.
-- ============================================================
WITH base_query AS (
    SELECT 
        f.order_number,
        f.customer_key,
        f.order_date,
        f.sales_amount,
        f.quantity,
        p.product_key,
        p.product_name,
        p.product_line,
        p.category,
        p.sub_category,
        p.product_cost,
        p.start_date
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p
        ON f.product_key = p.product_key
    WHERE f.order_date IS NOT NULL
),
product_aggregations AS (
    SELECT 
        product_key,
        product_name,
        category,
        sub_category,
        product_cost,
        DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan,
        MAX(order_date) AS last_sale_date,
        COUNT(DISTINCT order_number) AS total_orders,
        COUNT(DISTINCT customer_key) AS total_customers,
        SUM(sales_amount) AS total_sales,
        SUM(quantity) AS total_quantity,
        ROUND(AVG(CAST(sales_amount AS FLOAT) / NULLIF(quantity, 0)), 1) AS avg_selling_price
    FROM base_query
    GROUP BY 
        product_key,
        product_name,
        category,
        sub_category,
        product_cost
)
SELECT 
    product_key,
    product_name,
    category,
    sub_category,
    product_cost,
    last_sale_date,
    DATEDIFF(MONTH, last_sale_date, GETDATE()) AS recency_in_months,
    CASE 
        WHEN total_sales > 50000 THEN 'High-Performer'
        WHEN total_sales >= 10000 THEN 'Mid-Range'
        ELSE 'Low-Performer' 
    END AS product_segment,
    lifespan,
    total_orders,
    total_sales,
    total_quantity,
    total_customers,
    avg_selling_price,
    CASE 
        WHEN total_orders = 0 THEN 0
        ELSE total_sales / total_orders 
    END AS avg_order_revenue,
    CASE 
        WHEN lifespan = 0 THEN total_sales
        ELSE total_sales / lifespan 
    END AS avg_monthly_revenue
FROM product_aggregations;

-- ============================================================
-- 5. FINAL VIEW CREATION
-- Purpose:
--   Creates a permanent view in the gold layer for product analytics.
--   This view can be used directly for dashboards and business reports.
-- ============================================================
CREATE VIEW gold.report_products AS
WITH base_query AS (
    SELECT 
        f.order_number,
        f.customer_key,
        f.order_date,
        f.sales_amount,
        f.quantity,
        p.product_key,
        p.product_name,
        p.product_line,
        p.category,
        p.sub_category,
        p.product_cost,
        p.start_date
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p
        ON f.product_key = p.product_key
    WHERE f.order_date IS NOT NULL
),
product_aggregations AS (
    SELECT 
        product_key,
        product_name,
        category,
        sub_category,
        product_cost,
        DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan,
        MAX(order_date) AS last_sale_date,
        COUNT(DISTINCT order_number) AS total_orders,
        COUNT(DISTINCT customer_key) AS total_customers,
        SUM(sales_amount) AS total_sales,
        SUM(quantity) AS total_quantity,
        ROUND(AVG(CAST(sales_amount AS FLOAT) / NULLIF(quantity, 0)), 1) AS avg_selling_price
    FROM base_query
    GROUP BY 
        product_key,
        product_name,
        category,
        sub_category,
        product_cost
)
SELECT 
    product_key,
    product_name,
    category,
    sub_category,
    product_cost,
    last_sale_date,
    DATEDIFF(MONTH, last_sale_date, GETDATE()) AS recency_in_months,
    CASE 
        WHEN total_sales > 50000 THEN 'High-Performer'
        WHEN total_sales >= 10000 THEN 'Mid-Range'
        ELSE 'Low-Performer' 
    END AS product_segment,
    lifespan,
    total_orders,
    total_sales,
    total_quantity,
    total_customers,
    avg_selling_price,
    CASE 
        WHEN total_orders = 0 THEN 0
        ELSE total_sales / total_orders 
    END AS avg_order_revenue,
    CASE 
        WHEN lifespan = 0 THEN total_sales
        ELSE total_sales / lifespan 
    END AS avg_monthly_revenue
FROM product_aggregations;
